{
  "schemaVersion": "2.2",
  "description": "SSM Document to apply one or more DSC MOFs",
  "parameters": {
    "MofsToApply": {
      "type": "String",
      "description": "A comma seperated list of MOF files to apply. Files can be from S3 (e.g. s3:bucketName:fileKey or s3:bucketRegion:bucketName:fileKey), HTTP/S (e.g. https://mydomain.com/MyMof.mof) or File System (e.g. \\\\MyServer\\MyShare\\MyMof.mof)",
      "default": "https://s3-us-west-1.amazonaws.com/aws-ssm-us-west-1/statemanagerdocumentspayload/AWS-ApplyDSCMofs/HelloWorld.mof",
      "allowedPattern": "[a-zA-Z0-9\\:\\-_/\\.,\\\\]+"
    },
    "ServicePath": {
      "type": "String",
      "description": "The prefix used when writing reports and status to S3.",
      "default": "default",
      "allowedPattern": "[a-z0-9\\-_/\\.]+"
    },
    "MofOperationMode": {
      "type": "String",
      "description": "The mode to use when applying the MOFs, either 'Apply' (will correct non-compliant resources) or 'ReportOnly' (will not correct non-compliant resources).",
      "default": "Apply",
      "allowedValues": [
        "Apply",
        "ReportOnly"
      ]
    },
    "ReportBucketName": {
      "type": "String",
      "description": "(Optional) The name of the S3 bucket to write compliance reports to. This is the bucket that the JSON formatted reports will be saved in, using the ServicePath as the key prefix. This should be in the format bucketregion:bucketname e.g. us-west-2:mybucket",
      "default": "",
      "allowedPattern": "[a-z0-9\\-_/\\.\\:]*"
    },
    "StatusBucketName": {
      "type": "String",
      "description": "(Optional) The name of the S3 bucket to write status reports to. These are singleton summaries of the most recent compliance run of an instance. It should be in the format bucketregion:bucketname e.g. us-west-2:mybucket",
      "default": "",
      "allowedPattern": "[a-z0-9\\-_/\\.\\:]*"
    },
    "ModuleSourceBucketName": {
      "type": "String",
      "description": "(Optional) The name of the S3 bucket containing module files. If no bucket is to be used, specify 'NONE' and ensure the 'AllowPSGalleryModuleSource' parameter is set to 'True'. It should be in the format bucketregion:bucketname e.g. us-west-2:mybucket",
      "default": "NONE",
      "allowedPattern": "(NONE)|[a-z0-9\\-_/\\.\\:]+"
    },
    "AllowPSGalleryModuleSource": {
      "type": "String",
      "description": "(Optional) True if modules can be downloaded from PSGallery. If this is false, the 'ModuleSourceBucketName' parameter should be used.",
      "default": "True",
      "allowedValues": [
        "True",
        "False"
      ]
    },
    "ProxyUri": {
      "type": "String",
      "description": "(Optional) The Uri of a proxy server to use",
      "default": "",
      "allowedPattern": "[a-zA-Z0-9\\:\\-_/\\.]*"
    },
    "RebootBehavior": {
      "type": "String",
      "description": "(Optional) The reboot behavior that the script will have should it need to reboot the machine. Default is 'AfterMof'",
      "default": "AfterMof",
      "allowedValues": [
        "AfterMof",
        "Immediately",
        "Never"
      ]
    },
    "UseComputerNameForReporting": {
      "type": "String",
      "description": "(Optional) Use the ComputerName for reporting instead of the Instance Id. Default is 'False'",
      "default": "False",
      "allowedValues": [
        "True",
        "False"
      ]
    },
    "EnableVerboseLogging": {
      "type": "String",
      "description": "(Optional) Enables Verbose logging, useful when deploying MOFs for the first time. Make sure you have lifecycle policies enabled on your logging bucket if you use this all the time.",
      "default": "False",
      "allowedValues": [
        "True",
        "False"
      ]
    },
    "EnableDebugLogging": {
      "type": "String",
      "description": "(Optional) Enables Debug logging, useful when troubleshooting a failing MOF. Don't use in day to day operation.",
      "default": "False",
      "allowedValues": [
        "True",
        "False"
      ]
    },
    "ComplianceType": {
      "type": "String",
      "description": "(Optional) The compliance type to use when reporting compliance. Default is 'Custom:DSC'. Each association should have a different ComplianceType value.",
      "default": "Custom:DSC",
      "allowedPattern": "Custom\\:[a-zA-Z0-9\\-_\\.]+"
    },
    "PreRebootScript": {
      "type": "String",
      "description": "(Optional) A script to execute prior to the instance rebooting if the configuration has indicated that a reboot is necessary. Your script must be a single line, but can be separated by semi-colons.",
      "default": "",
      "allowedPattern": ".*"
    }
  },
  "mainSteps": [
    {
      "action": "aws:runPowerShellScript",
      "name": "RunPowerShell",
      "inputs": {
        "timeoutSeconds": 10800,
        "runCommand": [
          "##################################################################################",
          "# License",
          "##################################################################################",
          "",
          "# This Document is protected under the Amazon Software License.",
          "# https://aws.amazon.com/asl/",
          "",
          "##################################################################################",
          "# Basic environment validation",
          "##################################################################################",
          "",
          "if (-not $env:SSM_DOCUMENT_NAME) {",
          "    [Environment]::SetEnvironmentVariable('SSM_DOCUMENT_NAME', 'AWS-ApplyDSCMofs')",
          "}",
          "#Requires -Version 5.1",
          "#Requires -Module PackageManagement,PowerShellGet",
          "if ($env:AWS_SSM_INSTANCE_ID -and $env:AWS_SSM_INSTANCE_ID.StartsWith('mi-')) {",
          "    [Environment]::SetEnvironmentVariable('AWS_REGION', $env:AWS_SSM_REGION_NAME)",
          "}",
          "",
          "",
          "##################################################################################",
          "# Network Configuration",
          "##################################################################################",
          "",
          "if (-not [Net.ServicePointManager]::SecurityProtocol.HasFlag([Net.SecurityProtocolType]::Tls12)) {",
          "    [Net.ServicePointManager]::SecurityProtocol = ([Net.ServicePointManager]::SecurityProtocol + [Net.SecurityProtocolType]::Tls12)",
          "}",
          "$global:ProxyUri = '{{ProxyUri}}'",
          "",
          "##################################################################################",
          "# Error handler",
          "##################################################################################",
          "",
          "$ErrorActionPreference = 'Stop'",
          "$global:stackt = New-Object 'System.Collections.Generic.Stack[string]'",
          "",
          "trap",
          "{",
          "    $separator = '##################################################################'",
          "    $err = New-Object System.Text.StringBuilder([Environment]::NewLine)",
          "    [Void]$err.AppendLine($separator)",
          "    [Void]$err.AppendLine('# Error Message')",
          "    [Void]$err.AppendLine($separator)",
          "    [Void]$err.AppendFormat('{0} (line {1}){2}', $_.Exception.Message, $_.InvocationInfo.ScriptLineNumber, [Environment]::NewLine)",
          "    [Void]$err.AppendLine($separator)",
          "    [Void]$err.AppendLine('# Failing command')",
          "    [Void]$err.AppendLine($separator)",
          "    [Void]$err.AppendLine($_.InvocationInfo.Line.Trim())",
          "    [Void]$err.AppendLine($separator)",
          "    [Void]$err.AppendLine('# Base Exception')",
          "    [Void]$err.AppendLine($separator)",
          "    [Void]$err.AppendLine($_.Exception.GetBaseException())",
          "    [Void]$err.AppendLine($separator)",
          "",
          "    if ($global:stackt.Count -gt 0)",
          "    {",
          "        [Void]$err.AppendLine('# Script stack trace')",
          "        [Void]$err.AppendLine($separator)",
          "        [Void]$err.AppendLine(([String]::Join([Environment]::NewLine, $global:stackt)))",
          "        [Void]$err.AppendLine($separator)",
          "    }",
          "",
          "    [Void]$err.AppendLine('# PSGarbage')",
          "    [Void]$err.AppendLine($separator)",
          "    Write-Error $err.ToString() -ErrorAction Continue",
          "    $exitCode = $_.InvocationInfo.ScriptLineNumber",
          "    if ($null -eq $exitCode -or $exitCode -eq 0) { $exitCode = 1 }",
          "",
          "    if ($global:ShouldPostMetrics)",
          "    {",
          "        PostDocumentMetric -DocumentName $env:SSM_DOCUMENT_NAME -ExitCode $exitCode",
          "    }",
          "",
          "    if ($env:SSMDocumentLogFileName)",
          "    {",
          "        $err.ToString() | Add-Content -Path $env:SSMDocumentLogFileName -Force -EA SilentlyContinue",
          "    }",
          "",
          "    \"Exiting with code '$exitCode'\"",
          "    [Environment]::Exit($exitCode)",
          "}",
          "",
          "##################################################################################",
          "# Logging functions",
          "##################################################################################",
          "",
          "# If the global variable for enabling verbose logging is set to false, each function will return immediately.",
          "# Verbose logging can be a little intense for large documents, so this option may be desirable to reduce S3 storage costs.",
          "",
          "Function LogFunction",
          "{",
          "    [CmdletBinding()]",
          "    param",
          "    (",
          "        [System.Management.Automation.InvocationInfo]$Info,",
          "        [ValidateSet('Start','End')]",
          "        [String]$Stage,",
          "        [Switch]$DebugOnly",
          "    )",
          "    ",
          "    if ($false -eq $global:EnableVerboseLogging) { return }",
          "",
          "    switch ($Stage)",
          "    {",
          "        'Start' {",
          "            $sb = New-Object System.Text.StringBuilder",
          "            [Void]$sb.AppendFormat(' from Function: {0} (called from line {1})', $Info.MyCommand.Name.Trim(), $Info.ScriptLineNumber)",
          "            if ($Info.BoundParameters.Count -gt 0)",
          "            {",
          "                [Void]$sb.AppendFormat(' with params: {0}', ($Info.BoundParameters | ConvertTo-Json -Depth 4 -Compress))",
          "            }",
          "",
          "            $global:stackt.Push($sb.ToString())",
          "            $spaces = ''.PadRight($global:stackt.Count, ' ')",
          "            $msg = '[{0:yyyy-MM-dd HH:mm:ss.fff}]{1}Starting function {2}' -f [DateTime]::Now, $spaces, $sb.ToString().Substring(16)",
          "            if ($DebugOnly) { Write-Debug $msg } else { Write-Verbose $msg }",
          "        }",
          "        'End' {",
          "            [Void]$global:stackt.Pop()",
          "            $spaces = ''.PadRight($global:stackt.Count, ' ')",
          "            $msg = '[{0:yyyy-MM-dd HH:mm:ss.fff}] {1}Ending function {2}' -f [DateTime]::Now, $spaces, $Info.MyCommand",
          "            if ($DebugOnly) { Write-Debug $msg } else { Write-Verbose $msg }",
          "        }",
          "    }",
          "",
          "    if ($env:SSMDocumentLogFileName)",
          "    {",
          "        $msg | Add-Content -Path $env:SSMDocumentLogFileName -Force -EA SilentlyContinue",
          "    }",
          "}",
          "",
          "Function LogMessage",
          "{",
          "    [CmdletBinding()]",
          "    param",
          "    (",
          "        [String]$Message,",
          "        [Switch]$DebugOnly",
          "    )",
          "",
          "    if ($false -eq $global:EnableVerboseLogging) { return }",
          "",
          "    $spaces = ''.PadRight($global:stackt.Count, ' ')",
          "    $msg = '[{0:yyyy-MM-dd HH:mm:ss.fff}] {1}{2}' -f [DateTime]::Now, $spaces, $Message",
          "    if ($DebugOnly) { Write-Debug $Message } else { Write-Verbose $msg -Verbose }",
          "",
          "    if ($env:SSMDocumentLogFileName)",
          "    {",
          "        $msg | Add-Content -Path $env:SSMDocumentLogFileName -Force -EA SilentlyContinue",
          "    }",
          "}",
          "",
          "##################################################################################",
          "# Document variables",
          "##################################################################################",
          "",
          "$scriptPath = \"$env:TMP\\AWS-ApplyDSCMofs-20190430.ps1\"",
          "$bucketName = 'aws-ssm-{0}' -f $env:AWS_SSM_REGION_NAME",
          "$key = 'statemanagerdocumentspayload/AWS-ApplyDSCMofs/AWS-ApplyDSCMofs-20190430.ps1'",
          "$functionsHash = '48e8aca6eb7bb055b0481bb834a5a6c60c136ffb47caf908948261bef2fcc569'",
          "if ($env:AWS_SSM_REGION_NAME.StartsWith(\"cn-\")) {",
          "    $uri = [Uri]\"https://s3.$env:AWS_SSM_REGION_NAME.amazonaws.com.cn/$bucketName/$key\"",
          "} elseif ($env:AWS_SSM_REGION_NAME -eq \"us-east-1\") {",
          "    $uri = [Uri]\"https://s3.amazonaws.com/$bucketName/$key\"",
          "} else {",
          "    $uri = [Uri]\"https://s3-$env:AWS_SSM_REGION_NAME.amazonaws.com/$bucketName/$key\"",
          "}",
          "##################################################################################",
          "# Download Script Function",
          "##################################################################################",
          "",
          "# NOTE: This library was added to .NET in version 4.5. Any Document that uses this library",
          "# will only run on systems that have .NET 4.5 or greater installed.",
          "# Server 2012 R2 comes with 4.5.1 pre-installed, which is the minimum we will support.",
          "[Void][System.Reflection.Assembly]::LoadWithPartialName('System.Net.Http')",
          "$global:HttpLoaded = $true",
          "",
          "$handler = New-Object System.Net.Http.HttpClientHandler",
          "",
          "if (-not [String]::IsNullOrWhiteSpace($global:ProxyUri))",
          "{",
          "    $handler.Proxy = New-Object System.Net.WebProxy($global:ProxyUri, $true)",
          "}",
          "",
          "$wc = New-Object System.Net.Http.HttpClient($handler, $true)",
          "",
          "try",
          "{",
          "    $request = New-Object System.Net.Http.HttpRequestMessage('Get', $uri)",
          "",
          "    if ([IO.File]::Exists($scriptPath))",
          "    {",
          "        $md5 = (Get-FileHash -Path $scriptPath -Algorithm MD5).Hash.ToLower()",
          "        $etag = [System.Net.Http.Headers.EntityTagHeaderValue]::Parse(\"`\"$md5`\"\")",
          "        $request.Headers.IfNoneMatch.Add($etag)",
          "    }",
          "",
          "    LogMessage \"Sending HTTP Get request to '$uri'\"",
          "    $response = $wc.SendAsync($request).Result",
          "",
          "    LogMessage ('Received response with status code {0}' -f $response.StatusCode)",
          "    if ($response.StatusCode -eq 'NotModified')",
          "    {",
          "        LogMessage 'Local file matches remote file, no content was downloaded.'",
          "    }",
          "    elseif ($response.StatusCode -eq 'BadRequest')",
          "    {",
          "        $er = $response.Content.ReadAsStringAsync().Result",
          "        throw \"Failed to download file: $er\"",
          "    }",
          "    elseif ($response.StatusCode -ne 'Ok')",
          "    {",
          "        throw \"Received non-success status code '$($response.StatusCode)' when attempting to download file '$uri'.\"",
          "    }",
          "    else",
          "    {",
          "        LogMessage 'Local file did not exist, or did not match remote file ETag (MD5) value. New content was downloaded.'",
          "        $fs = New-Object System.IO.FileStream($scriptPath, [IO.FileMode]::OpenOrCreate, [IO.FileAccess]::ReadWrite, [IO.FileShare]::Read, 4096, [IO.FileOptions]::Encrypted)",
          "        try",
          "        {",
          "            $response.Content.CopyToAsync($fs).Wait()",
          "        }",
          "        finally",
          "        {",
          "            $fs.Dispose()",
          "        }",
          "    }",
          "}",
          "finally",
          "{",
          "    $wc.Dispose()",
          "    if ($request) { $request.Dispose() }",
          "    if ($response) { $response.Dispose() }",
          "}",
          "",
          "if ($functionsHash)",
          "{",
          "    $downloadedFileHash = (Get-FileHash -Path $scriptPath -Algorithm SHA256).Hash.ToLower()",
          "    if ($functionsHash -ne $downloadedFileHash)",
          "    {",
          "        throw \"Downloaded Functions file hash should have been '$functionsHash', but it was '$downloadedFileHash'. Script will terminate.\"",
          "    }",
          "}",
          "",
          "LogMessage 'Importing script functions'",
          ". $scriptPath",
          "",
          "##################################################################################",
          "# Start Script",
          "##################################################################################",
          "",
          "# Here we sub all of the script inputs from SSM document parameters.",
          "# Some are set to inputs to the main function (InvokeComplianceRun), while others",
          "# are set to global variables (when they need to be referenced by support functions)",
          "# Any code that references a global variable set here will expect a null variable",
          "# or empty string value as a legit input. This is to prevent null reference",
          "# exceptions in unit tests, and because not all of these inputs MUST have values.",
          "",
          "[Ref]$bool = $false",
          "if ([Boolean]::TryParse('{{AllowPSGalleryModuleSource}}', $bool))",
          "{",
          "    $global:AllowPSGalleryModuleSource = $bool.Value",
          "}",
          "",
          "if ([Boolean]::TryParse('{{UseComputerNameForReporting}}', $bool))",
          "{",
          "    $global:UseComputerNameForReporting = $bool.Value",
          "}",
          "",
          "$global:ModuleSourceBucketName = '{{ModuleSourceBucketName}}'",
          "if ($global:ModuleSourceBucketName -eq 'NONE') { $global:ModuleSourceBucketName = [String]::Empty }",
          "",
          "$global:ProxyUri = '{{ProxyUri}}'",
          "",
          "# Ensure that all of the dependencies of the script are met",
          "EnsureScriptDependencies",
          "",
          "# If a ProxyUri is set, run the Set-AWSProxy so that all of the AWS Cmdlets",
          "# automatically use the specified proxy. Needs to run after EnsureScriptDependencies.",
          "if (-not [String]::IsNullOrWhiteSpace($global:ProxyUri))",
          "{",
          "    $proxy = [Uri]$global:ProxyUri",
          "    Set-AWSProxy -Hostname $proxy.Host -Port $proxy.Port",
          "}",
          "",
          "# Run these AFTER EnsuringScriptDependencies to avoid a TON of garbage messages.",
          "# Enabling DebugLogging will also enable Verbose logging, regardless of the settings.",
          "if ([Boolean]::TryParse('{{EnableDebugLogging}}', $bool) -and $bool.Value)",
          "{",
          "    $global:EnableDebugLogging = $true",
          "    $global:EnableVerboseLogging = $true",
          "    $DebugPreference = 'Continue'",
          "    $VerbosePreference = 'Continue'",
          "    [Environment]::SetEnvironmentVariable('SSMDocumentLogFileName', \"$env:ProgramData\\SSMDocumentLogs\\$env:SSM_DOCUMENT_NAME.txt\")",
          "    $null = New-Item -ItemType File -Path $env:SSMDocumentLogFileName -Force",
          "}",
          "elseif ([Boolean]::TryParse('{{EnableVerboseLogging}}', $bool) -and $bool.Value)",
          "{",
          "    $global:EnableVerboseLogging = $true",
          "    $VerbosePreference = 'Continue'",
          "}",
          "",
          "# Since the PreRebootScript parameter will almost certainly have quotes in it, we need to",
          "# inject it inside a multiline variable so that it doesn't cause the document to fail parsing.",
          "$preRebootScript = @'",
          "{{PreRebootScript}}",
          "'@.Trim()",
          "",
          "if (-not [String]::IsNullOrWhiteSpace($preRebootScript))",
          "{",
          "    try",
          "    {",
          "        LogMessage 'Parsing PreRebootScript into ScriptBlock'",
          "        $preRebootScriptBlock = [ScriptBlock]::Create($preRebootScript)",
          "    }",
          "    catch",
          "    {",
          "        throw \"Failed to parse PreRebootScript: $_\"",
          "    }",
          "}",
          "",
          "$mofsToApply = @('{{MofsToApply}}'.Trim() -split ',\\s*')",
          "if ($mofsToApply.Count -eq 1 -and $mofsToApply[0].EndsWith('.instructions'))",
          "{",
          "    $paramObject = Get-Content -Path $mofsToApply[0] | ConvertFrom-Json",
          "    $params = @{}",
          "    foreach ($param in $paramObject.PSObject.Properties)",
          "    {",
          "        $params.Add($param.Name, $param.Value)",
          "    }",
          "}",
          "else",
          "{",
          "    # These variables all must have values, but we've left it to SSM parameter",
          "    # validation to ensure they are set.",
          "    $params = @{",
          "        MofsToApply = $mofsToApply",
          "        MofOperationMode = '{{MofOperationMode}}'",
          "        RebootBehavior = '{{RebootBehavior}}'",
          "        ServicePath = '{{ServicePath}}'",
          "        ReportBucketName = '{{ReportBucketName}}'",
          "        StatusBucketName = '{{StatusBucketName}}'",
          "        ComplianceType = '{{ComplianceType}}'",
          "    }",
          "}",
          "",
          "# Since default values in SSM documents don't apply to invocations triggered by the API,",
          "# we're going to have to sub in default values if they were not supplied.",
          "$defaultValues = @{",
          "    ServicePath = 'default'",
          "    ComplianceType = 'Custom:DSC'",
          "    MofOperationMode = 'Apply'",
          "    RebootBehavior = 'AfterMof'",
          "}",
          "",
          "foreach ($parameterName in $defaultValues.Keys)",
          "{",
          "    if ([String]::IsNullOrWhiteSpace($params[$parameterName]))",
          "    {",
          "        $params[$parameterName] = $defaultValues[$parameterName]",
          "    }",
          "}",
          "",
          "# InvokeComplianceRun will return the number of non-compliant resources, or, if the machine requires a reboot, ",
          "# it will return a 3010 code. We want to pass it through so that the SSM agent will reboot the machine and rerun the document.",
          "",
          "# If the script fails due to any other reason it will exit with the line number at which the error occurred (i.e. non-zero).",
          "# This is handled by the global error handler in the Document.",
          "",
          "$exitCode = InvokeComplianceRun @params",
          "if ($exitCode -eq 3010)",
          "{",
          "    LogMessage 'Exit code indicates reboot is required'",
          "",
          "    if ($preRebootScriptBlock)",
          "    {",
          "        # InvokePreRebootScript returns true if machine should reboot,",
          "        # false if the reboot was cancelled within the reboot script.",
          "        # If reboot was cancelled, we will fail the association.",
          "        if (-not (InvokePreRebootScript -ScriptBlock $preRebootScriptBlock))",
          "        {",
          "            [Environment]::Exit(1)",
          "        }",
          "    }",
          "",
          "    [Environment]::Exit(3010)",
          "}",
          "",
          "##################################################################################",
          "# End Script",
          "##################################################################################"
        ]
      }
    }
  ]
}
