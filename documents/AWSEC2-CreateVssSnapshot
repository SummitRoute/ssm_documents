{
  "schemaVersion": "2.2",
  "description": "Create an application consistent snapshot of all EBS volumes attached to an instance.",
  "parameters": {
    "ExcludeBootVolume": {
      "type": "String",
      "description": "(Optional) Select True to exclude the boot volume from the snapshot process.",
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False"
    },
    "NoWriters": {
      "type": "String",
      "description": "(Optional) Select True to exclude application VSS writers from the snapshot process. This option may be useful to resolve conflicts with third party VSS backup solutions.",
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False"
    },
    "CopyOnly": {
      "type": "String",
      "description": "(Optional) Select True to indicate a COPY ONLY backup operation.  By default a FULL backup operation is performed.  This option will prevent breaking the differential backup chain in SQL Server when performing a backup.",
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False"
    },
    "description": {
      "type": "String",
      "default": "",
      "description": "(Optional) Specify a description to apply to created EBS snaphots.",
      "maxChars": 255
    },
    "tags": {
      "type": "String",
      "default": "Key=Name,Value=",
      "description": "(Optional) Specify descriptive key-value pair tags to apply to created EBS snapshots.  Use a semicolon as a separator between tags pairs. Example: Key=Name,Value=VSS Snapshot;Key=BackupId,Value=01234",
      "allowedPattern": "^([Kk]ey=(.*),[Vv]alue=(.*);?)*$"
    }
  },
  "mainSteps": [
    {
      "precondition": {
        "StringEquals": [
          "platformType",
          "Windows"
        ]
      },
      "action": "aws:runPowerShellScript",
      "name": "runPowerShellScript",
      "inputs": {
        "runCommand": [
          "# Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
          "",
          "$EBS_VOLUME_MATCH = '(?<=vol).*(?=_)'",
          "$EBS_VOLUME_MATCH2 = '(?<=vol)(.*)'",
          "",
          "",
          "#",
          "# Function to begin the VSS snapshot of a EBS volume",
          "#",
          "function EbsVssFreeze {",
          "    param (",
          "        [string]$driveLetter,",
          "        [DateTime]$startTime,",
          "        [boolean]$copyOnly,",
          "        [boolean]$noWriters",
          "    )",
          "",
          "    if ($script:inProgress -eq $true) {",
          "        return",
          "    }",
          "",
          "",
          "    $namedPipe = '01C0026F-7357-49CD-BD74-657EAF079673'",
          "    $pipeServer = new-object System.IO.Pipes.NamedPipeServerStream($namedPipe, ",
          "        [System.IO.Pipes.PipeDirection]::In,",
          "        1,",
          "        [System.IO.Pipes.PipeTransmissionMode]::Byte)",
          "",
          "    Write-Host 'Pipe server started after' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "",
          "    $script:inProgress = $true",
          "",
          "    $vssAgentPath = \"$env:ProgramFiles\\Amazon\\AwsVssComponents\\ec2-vss-agent.exe\"",
          "    if (Test-Path \"$vssAgentPath\") {",
          "        if ((get-process \"ec2-vss-agent\" -ea SilentlyContinue) -ne $Null) { ",
          "            Write-Host \"ec2-vss-agent is current running, snapshot already in progress.\" ",
          "            exit 1",
          "        }",
          "",
          "        $params = $driveLetter",
          "",
          "        if ($copyOnly) {",
          "            Write-Host \"Copy only option selected\"",
          "            $params = \"-copy \" + $params",
          "        }",
          "",
          "        if ($noWriters) {",
          "            Write-Host \"No writers option selected\"",
          "            $params = \"-nw \" + $params",
          "        }",
          "        ",
          "        $process = Start-Process $vssAgentPath $params -PassThru",
          "    ",
          "    } else {",
          "        Write-Host 'ec2-vss-agent.exe is not installed. To install, run command AWS-ConfigureAWSPackage with package AwsVssComponents'",
          "        exit 1",
          "    }",
          "    Write-Host 'Waiting for Freeze pipe at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "",
          "    #",
          "    # Wait for connection from provider indicating VSS freeze has begun",
          "    #",
          "    $pipeServer.WaitForConnection()",
          "    Write-Host 'Freeze pipe connected at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "    try {",
          "        $pipeReader = new-object System.IO.StreamReader($pipeServer)",
          "        $string = $pipeReader.ReadLine()",
          "        Write-Host 'EBS snapshot Freeze message received at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms' $string",
          "",
          "    } catch {",
          "        Write-Host \"Freeze pipe read failed at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "        Write-Error  $_",
          "    } finally {",
          "        Write-Host 'Disposing of pipes at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "        $pipeReader.Dispose()",
          "        $pipeServer.Dispose()",
          "    }",
          "}",
          "",
          "",
          "#",
          "# Function to release VSS freeze of EBS volume after snapshot is complete.",
          "#",
          "function EbsVssThaw($startTime = (Get-Date)) {",
          "",
          "    # Return if a VSS snapshot is not in progress",
          "    if ($script:inProgress -eq $false) {",
          "        Write-Host 'script not in progress'",
          "        return $false;",
          "    }",
          "",
          "    $namedPipe = '8ef5c9e5-9c84-43eb-a8f7-c60b0efd7b72'",
          "    $pipeClient = new-object System.IO.Pipes.NamedPipeClientStream(\".\",",
          "        $namedPipe, ",
          "        [System.IO.Pipes.PipeDirection]::In,",
          "        [System.IO.Pipes.PipeOptions]::Asynchronous)",
          "",
          "    try {",
          "        Write-Host \"Thaw pipe waiting for connection at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "        # Wait for thaw connection from provider",
          "        $pipeClient.Connect(10000)",
          "        Write-Host \"Thaw pipe connected at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "        try {",
          "            $pipeReader = new-object System.IO.StreamReader($pipeClient)",
          "",
          "            $string = $pipeReader.ReadLine()",
          "        } catch {",
          "            Write-Host \"Thaw pipe read failed at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "            Write-Error  $_",
          "        ",
          "        } finally {",
          "            $pipeReader.Dispose()",
          "        }",
          "    } catch {",
          "        Write-Host \"Thaw pipe connection failed at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "        Write-Error  $_",
          "        ",
          "    } finally {",
          "        $pipeClient.Dispose()",
          "    }",
          "",
          "    Write-Host \"Pipe message read at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "",
          "    $script:inProgress = $false",
          "",
          "    if ($string -like 'EBS done') {",
          "        return $true",
          "    } else {",
          "        Write-Host \"Thaw pipe returned wrong value: \" $string ",
          "        return $false",
          "    }",
          "}",
          "",
          "",
          "#",
          "# Helper function to retrieve EC2 instance meta-data.",
          "#",
          "function Get-EC2InstanceMetadata {",
          "    param([string]$Path)",
          "    Invoke-RestMethod -Uri \"http://169.254.169.254/latest/$Path\"",
          "}",
          "",
          "",
          "#",
          "# Helper function to convert SCSI target ID to xvd* EBS device name.",
          "#",
          "function Convert-SCSITargetIdToDeviceName {",
          "    param([int]$SCSITargetId)",
          "    If ($SCSITargetId -eq 0) {",
          "        return '/dev/sda1'",
          "    }",
          "    $deviceName = 'xvd'",
          "    If ($SCSITargetId -gt 25) {",
          "        $deviceName += [char](0x60 + [int]($SCSITargetId / 26))",
          "    }",
          "    $deviceName += [char](0x61 + $SCSITargetId % 26)",
          "    return $deviceName",
          "}",
          "",
          "",
          "#",
          "# Retrieve Storage Spaces drive mapping with EBS volume ID for C5 and newer instance types",
          "#",
          "function Get-AwsNvmeStorageSpacesEbsDiskMapping {",
          "    ",
          "    $disklist = @()",
          "",
          "    # Exit if we are not on at least Server 2012",
          "    if (([Decimal]([environment]::OSVersion.Version).Major + [Decimal]([environment]::OSVersion.Version).Minor * .1) -lt 6.2) {",
          "        return $null",
          "    }",
          "",
          "    $physicalDisks = Get-PhysicalDisk | Where-Object {",
          "        $_.SerialNumber -match $EBS_VOLUME_MATCH -or $_.AdapterSerialNumber -match $EBS_VOLUME_MATCH2",
          "    }",
          "    ",
          "    if ($physicalDisks.Count -eq 0) {",
          "        return $null",
          "    }",
          "    ",
          "    foreach ($pd in $physicalDisks) {",
          "",
          "        $pool1 = Get-StoragePool -PhysicalDisk $pd -IsPrimordial $False -ErrorAction SilentlyContinue",
          "",
          "        $volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "        ",
          "        if ($volumeNumber -eq $null) {",
          "            $volumeNumber = $pd.AdapterSerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "        }",
          "",
          "        $ebsVolumeId = \"vol-$volumeNumber\"",
          "",
          "        foreach ($vd in Get-VirtualDisk) {",
          "            $pool2 = Get-StoragePool -VirtualDisk $vd",
          "            if ($pool1 -like $pool2) {",
          "                $vol = ($vd | Get-Disk | Get-Partition | Get-Volume)",
          "                $diskList += New-Object PSObject -Property @{",
          "                    Disk          = If ($pd -eq $null) { $null } Else { $pd.DeviceId };",
          "                    Partitions    = 0;",
          "                    DriveLetter   = If ($vol -eq $null) { $null } Else { ($vol.DriveLetter + ':') };",
          "                    EbsVolumeId   = If ($pd -eq $null) { $null } Else { $ebsVolumeId };",
          "                    Device        = If ($pd -eq $null) { $null } Else { $pd.FriendlyName };",
          "                    VolumeName    = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };",
          "                }",
          "            }",
          "        }",
          "    }",
          "",
          "    return $disklist",
          "}",
          "",
          "",
          "#",
          "# Retrieve EBS volumes associated with a Storage Spaces pool ",
          "#",
          "function Get-XenStorageSpacesEbsDiskMapping {",
          "    ",
          "    $disklist = @()",
          "",
          "    # For XEN attached EBS volumes the attachment order will be the serial number",
          "    $ATTACHMENT_ORDER_MATCH = '^(\\d{4})$'",
          "",
          "    # Exit if we are not on at least Server 2012",
          "    if (([Decimal]([environment]::OSVersion.Version).Major + [Decimal]([environment]::OSVersion.Version).Minor * .1) -lt 6.2) {",
          "        return $null",
          "    }",
          "",
          "    $physicalDisks = Get-PhysicalDisk | Where-Object {$_.SerialNumber -match $ATTACHMENT_ORDER_MATCH -and $_.FriendlyName -like 'AWS PVDISK'}",
          "    ",
          "    if ($physicalDisks.Count -eq 0) {",
          "        return $null",
          "    }",
          "",
          "    $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
          "",
          "    $BlockDeviceMapping = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "",
          "    foreach ($pd in $physicalDisks) {",
          "",
          "        $BlockDeviceName = Convert-SCSITargetIdToDeviceName $pd.SerialNumber",
          "",
          "        $device = $BlockDeviceMapping | Where-Object {$_.DeviceName -like (\"*\" + $BlockDeviceName)}",
          "    ",
          "        $ebsVolumeId = $device.Ebs.VolumeId",
          "",
          "        $pool1 = Get-StoragePool -PhysicalDisk $pd -IsPrimordial $False -ErrorAction SilentlyContinue",
          "",
          "        foreach ($vd in Get-VirtualDisk) {",
          "            $pool2 = Get-StoragePool -VirtualDisk $vd",
          "            if (($pool1 -like $pool2) -and  ($ebsVolumeId -ne $null)) {",
          "                $vol = ($vd | Get-Disk | Get-Partition | Get-Volume)",
          "                $diskList += New-Object PSObject -Property @{",
          "                    Disk          = If ($pd -eq $null) { $null } Else { $pd.DeviceId };",
          "                    Partitions    = 0;",
          "                    DriveLetter   = If ($vol -eq $null) { $null } Else { ($vol.DriveLetter + ':') };",
          "                    EbsVolumeId   = If ($pd -eq $null) { $null } Else { $ebsVolumeId };",
          "                    Device        = If ($pd -eq $null) { $null } Else { $device.DeviceName  };",
          "                    VolumeName    = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };",
          "                }",
          "            }",
          "        }",
          "    }",
          "",
          "    return $disklist",
          "}",
          "",
          "",
          "#",
          "# Helper function to collect connected EBS volumes attached to local EC2 instance.",
          "#",
          "function Get-EbsDiskMapping {",
          "",
          "    Try {",
          "        $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
          "        $BlockDeviceMappings = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "    } Catch {",
          "        Write-Host \"Could not access the AWS API, therefore, VolumeId is not available. ",
          "        Verify that your instance role has Describe-Instances permission.\" -ForegroundColor Yellow",
          "        throw",
          "    }",
          "",
          "    $diskList = Get-WmiObject -Class Win32_DiskDrive | ForEach-Object {",
          "        $DiskDrive = $_",
          "        $Volumes = Get-WmiObject -Query \"ASSOCIATORS OF {Win32_DiskDrive.DeviceID='$($DiskDrive.DeviceID)'} WHERE AssocClass=Win32_DiskDriveToDiskPartition\" | ForEach-Object {",
          "            $DiskPartition = $_",
          "            Get-WmiObject -Query \"ASSOCIATORS OF {Win32_DiskPartition.DeviceID='$($DiskPartition.DeviceID)'} WHERE AssocClass=Win32_LogicalDiskToPartition\"",
          "        }",
          "        If ($DiskDrive.PNPDeviceID -like \"*PROD_PVDISK*\") {",
          "            $BlockDeviceName = Convert-SCSITargetIdToDeviceName($DiskDrive.SCSITargetId)",
          "            $BlockDevice = $BlockDeviceMappings | Where-Object { $_.DeviceName -like (\"*\" + $BlockDeviceName) }",
          "        } ElseIf ($DiskDrive.PNPDeviceID -like \"*PROD_AMAZON_ELASTIC_B*\") {",
          "            # If driver stack supports writing the EBS volume ID to SerialNumber then we use that",
          "            $volumeNumber = $DiskDrive.SerialNumber | Select-String $EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "   ",
          "            if ($volumeNumber -ne $null) {",
          "                $ebsVolumeId = \"vol-$volumeNumber\"",
          "                $BlockDevice = $BlockDeviceMappings | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "                $BlockDeviceName = $BlockDevice.DeviceName",
          "            } else {",
          "                $BlockDeviceName = Convert-SCSITargetIdToDeviceName($DiskDrive.SCSIPort)",
          "                $BlockDevice = $BlockDeviceMappings | Where-Object { $_.DeviceName -like (\"*\" + $BlockDeviceName) }",
          "            }",
          "",
          "        } ElseIf ($DiskDrive.PNPDeviceID -like \"*PROD_AMAZON_EC2_NVME*\") {",
          "            $BlockDeviceName = Get-EC2InstanceMetadata \"meta-data/block-device-mapping/ephemeral$($DiskDrive.SCSIPort - 2)\"",
          "            $BlockDevice = $null",
          "        } Else {",
          "            $BlockDeviceName = $null",
          "            $BlockDevice = $null",
          "        }",
          "        if ( $BlockDevice.Ebs.VolumeId -ne $null) {",
          "            New-Object PSObject -Property @{",
          "                Disk          = $DiskDrive.Index;",
          "                Partitions    = $DiskDrive.Partitions;",
          "                DriveLetter   = If ($Volumes -eq $null) { $null } Else { $Volumes.DeviceID };",
          "                EbsVolumeId   = If ($BlockDevice -eq $null) { $null } Else { $BlockDevice.Ebs.VolumeId };",
          "                Device        = If ($BlockDeviceName -eq $null) { $null } Else { $BlockDeviceName };",
          "                VolumeName    = If ($Volumes -eq $null) { $null } Else { $Volumes.VolumeName };",
          "            }",
          "        }",
          "    } | Sort-Object Disk",
          "",
          "    return $diskList",
          "}",
          "",
          "",
          "#",
          "# Get a mapping of the local drives to EBS volumes",
          "#",
          "function Get-EbsConnectedVolume",
          "{",
          "",
          "    $diskList = @()",
          "",
          "    $diskList += Get-EbsDiskMapping",
          "",
          "    $diskList += Get-XenStorageSpacesEbsDiskMapping",
          "",
          "    $diskList += Get-AwsNvmeStorageSpacesEbsDiskMapping",
          "",
          "    return $diskList",
          "}",
          "",
          "",
          "#",
          "# Tag Snapshots",
          "#",
          "function Tag-Snapshots {",
          "    param(",
          "        [System.Object[]]$SnapshotsData,",
          "        [boolean]$AppConsistent,",
          "        [Parameter(Mandatory = $false)][amazon.EC2.Model.Tag[]]$Tags",
          "    )",
          "    $Tag = new-object amazon.EC2.Model.Tag",
          "    $Tag.Key = \"AppConsistent\"",
          "    $Tag.Value = \"$AppConsistent\"",
          "    $Tags += $Tag",
          "    foreach ($SnapshotData in $SnapshotsData) {",
          "        $Tag = new-object amazon.EC2.Model.Tag",
          "        $Tag.Key = \"Device\"",
          "        $Tag.Value = $SnapshotData.Device",
          "        $AllTags = $Tags + $Tag",
          "        New-EC2Tag -Resources $SnapshotData.SnapshotId -Tags $AllTags",
          "    }",
          "}",
          "",
          "function VssSnapshot() {",
          "    param(",
          "        [boolean]$ExcludeBootVolume,",
          "        [boolean]$CopyOnly,",
          "        [boolean]$NoWriters,",
          "        [string]$Description,",
          "        [string]$Tags",
          "    )",
          "    $startTime = Get-Date",
          "    $VolumesToFreeze = @()",
          "    $DrivesToFreeze = @()",
          "",
          "    $volumeList = Get-EbsConnectedVolume",
          "    foreach ($v in $volumeList) {",
          "        if ( ($v.DriveLetter -ne $null) -and ($v.EbsVolumeId -ne $null)) {",
          "            if (($ExcludeBootVolume -eq $false) -or ($v.Device -ne \"/dev/sda1\")) {",
          "                $VolumesToFreezeString += ($v.DriveLetter -join ' ') + \" \"",
          "                $DrivesToFreeze += $v.DriveLetter",
          "                $VolumesToFreeze += $v",
          "            }",
          "        }",
          "    }",
          "    if ($VolumesToFreeze.Count -eq 0) {",
          "        Write-Host \"No mounted EBS drives detected\"",
          "        exit 1",
          "    }",
          "    $DrivesToFreezeString = ($DrivesToFreeze | sort -Unique) -join ' '",
          "",
          "    Write-Host \"Beginning snapshot for drives\" $DrivesToFreezeString",
          "",
          "    EbsVssFreeze $DrivesToFreezeString $startTime $CopyOnly $NoWriters",
          "",
          "    Write-Host 'Freeze complete at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "    $SnapshotData = @()",
          "    foreach ($v in $VolumesToFreeze) {",
          "        $Snapshot = New-EC2Snapshot -VolumeId $v.EbsVolumeId -Description $Description",
          "        $SnapshotData +=",
          "        New-Object PSObject -Property @{",
          "            EbsVolumeId = $v.EbsVolumeId",
          "            Device      = $v.Device",
          "            SnapshotId  = $Snapshot.SnapshotId",
          "        }   ",
          "        Write-Host \"Created\" $Snapshot.SnapshotId \"from\" $v.EbsVolumeId \" device: \" $v.Device",
          "    }",
          "",
          "    Write-Host 'Starting Thaw at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "    $AppConsistent = EbsVssThaw $startTime",
          "    if ($AppConsistent) {",
          "        Write-Host 'Thaw successful at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "    } else {",
          "        Write-Host 'Thaw unsuccesful, snapshots may not be app consistent, see event log for more details' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "    }",
          "",
          "    [amazon.EC2.Model.Tag[]]$TagArray = @()",
          "    $Tags -split \";\" | ForEach-Object {",
          "        if (-not [string]::IsNullOrEmpty($_)) {",
          "            $TagParts = ($_ -split \",\", 2)",
          "            if ($TagParts.Count -ne 2) {",
          "                Write-Host \"Error parsing tags, tags need to be in the format Name=tag-key,Values=tag-value\"",
          "                return $false",
          "            }",
          "            $TagName, $TagValue = $TagParts",
          "            $Tag = new-object amazon.EC2.Model.Tag",
          "            $Tag.Key = ($TagName -split \"=\", 2)[1].Trim()",
          "            $Tag.Value = ($TagValue -split \"=\", 2)[1].Trim()",
          "            $TagArray += $Tag",
          "        }",
          "    }",
          "",
          "",
          "    Tag-Snapshots $SnapshotData $AppConsistent $TagArray",
          "    return $AppConsistent",
          "}",
          "",
          "if ($callLocal -ne $true) {",
          "    [boolean]$ExcludeBootVolume = [System.Convert]::ToBoolean(\"{{ExcludeBootVolume}}\")",
          "",
          "    [boolean]$CopyOnly = [System.Convert]::ToBoolean(\"{{CopyOnly}}\")",
          "",
          "    [boolean]$NoWriters = [System.Convert]::ToBoolean(\"{{NoWriters}}\")",
          "",
          "    $description = @\"",
          "{{description}}",
          "\"@",
          "",
          "    $tags = @\"",
          "{{tags}}",
          "\"@",
          "",
          "    $AppConsistent = VssSnapshot $ExcludeBootVolume $CopyOnly $NoWriters $description $tags",
          "    exit [int](-not $AppConsistent)",
          "}",
          "",
          "",
          "",
          "",
          ""
        ],
        "workingDirectory": "",
        "timeoutSeconds": "400"
      }
    }
  ]
}
