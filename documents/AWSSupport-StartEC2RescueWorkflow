{
  "schemaVersion": "0.3",
  "description": "The AWSSupport-StartEC2RescueWorkflow automation document runs the provided base64 encoded script (Bash or Powershell) on a helper instance created to rescue your instance. The root volume of your instance is attached and mounted to the helper instance, also known as the EC2Rescue instance.",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "InstanceId": {
      "type": "String",
      "description": "(Required) ID of your EC2 instance. IMPORTANT: AWS Systems Manager Automation stops this instance. Data stored in instance store volumes will be lost. The public IP address will change if you are not using an Elastic IP.",
      "allowedPattern": "^i-[a-z0-9]{8,17}$"
    },
    "OfflineScript": {
      "type": "String",
      "description": "(Required) Base64 encoded script to execute against the helper instance. Use Bash if your source instance is Linux, and PowerShell if it is Windows.",
      "allowedPattern": "^[a-zA-Z0-9+/]{3,}[=]{0,2}$"
    },
    "EC2RescueInstanceType": {
      "type": "String",
      "description": "(Optional) The EC2 instance type for the EC2Rescue instance.",
      "default": "t2.small",
      "allowedValues": [
        "t2.small",
        "t2.medium",
        "t2.large"
      ]
    },
    "SubnetId": {
      "type": "String",
      "description": "(Optional) The subnet ID for the EC2Rescue instance. By default, the same subnet where the provided instance resides is used. IMPORTANT: If you provide a custom subnet, it must be in the same Availability Zone as InstanceId, and it must allow access to the SSM endpoints.",
      "default": "SelectedInstanceSubnet",
      "allowedPattern": "^SelectedInstanceSubnet$|^CreateNewVPC$|^subnet-[a-z0-9]{8,17}$"
    },
    "S3BucketName": {
      "description": "(Optional) S3 bucket name in your account where you want to upload the troubleshooting logs. Make sure the bucket policy does not grant unnecessary read/write permissions to parties that do not need access to the collected logs.",
      "allowedPattern": "^$|^[_a-zA-Z0-9][-._a-zA-Z0-9]{2,62}$",
      "type": "String",
      "default": ""
    },
    "S3Prefix": {
      "type": "String",
      "description": "(Optional) A prefix for the S3 logs.",
      "default": "AWSSupport-EC2Rescue",
      "allowedPattern": "^[a-zA-Z0-9][-./a-zA-Z0-9]{0,255}$"
    },
    "AMIPrefix": {
      "type": "String",
      "description": "(Optional) A prefix for the backup AMI name.",
      "default": "AWSSupport-EC2Rescue",
      "allowedPattern": "[-._a-zA-Z0-9]{3,20}$"
    },
    "CreatePreEC2RescueBackup": {
      "type": "String",
      "description": "(Optional) Set it to True to create an AMI of InstanceId before executing the script. The AMI will persist after the automation completes. It is your responsibility to secure access to the AMI, or to delete it.",
      "default": "False",
      "allowedValues": [
        "True",
        "False"
      ]
    },
    "CreatePostEC2RescueBackup": {
      "type": "String",
      "description": "(Optional) Set it to True to create an AMI of InstanceId after executing the script, before starting it. The AMI will persist after the automation completes. It is your responsibility to secure access to the AMI, or to delete it.",
      "default": "False",
      "allowedValues": [
        "True",
        "False"
      ]
    },
    "UniqueId": {
      "type": "String",
      "description": "(Optional) A unique identifier for the workflow.",
      "default": "{{ automation:EXECUTION_ID }}"
    },
    "AutomationAssumeRole": {
      "type": "String",
      "description": "(Optional) The ARN of the role that allows Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses your IAM permissions to execute this document.",
      "default": ""
    }
  },
  "mainSteps": [
    {
      "name": "describeInstance",
      "action": "aws:executeAwsApi",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ]
      },
      "outputs": [
        {
          "Name": "RootDeviceName",
          "Selector": "$.Reservations[0].Instances[0].RootDeviceName",
          "Type": "String"
        },
        {
          "Name": "State",
          "Selector": "$.Reservations[0].Instances[0].State.Name",
          "Type": "String"
        },
        {
          "Name": "SubnetId",
          "Selector": "$.Reservations[0].Instances[0].NetworkInterfaces[0].SubnetId",
          "Type": "String"
        },
        {
          "Name": "Platform",
          "Selector": "$.Reservations[0].Instances[0].Platform",
          "Type": "String"
        },
        {
          "Name": "AvailabilityZone",
          "Selector": "$.Reservations[0].Instances[0].Placement.AvailabilityZone",
          "Type": "String"
        }
      ],
      "isCritical": "true",
      "nextStep": "describeInstanceRootVolume"
    },
    {
      "name": "describeInstanceRootVolume",
      "action": "aws:executeAwsApi",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "Filters": [
          {
            "Name": "attachment.instance-id",
            "Values": [
              "{{ InstanceId }}"
            ]
          },
          {
            "Name": "attachment.device",
            "Values": [
              "{{ describeInstance.RootDeviceName }}"
            ]
          }
        ]
      },
      "outputs": [
        {
          "Name": "RootDeviceVolumeId",
          "Selector": "$.Volumes[0].Attachments[0].VolumeId",
          "Type": "String"
        },
        {
          "Name": "RootDeviceDeleteOnTermination",
          "Selector": "$.Volumes[0].Attachments[0].DeleteOnTermination",
          "Type": "Boolean"
        }
      ],
      "isCritical": "true",
      "nextStep": "assertInstanceRootVolumeIsEbs"
    },
    {
      "name": "assertInstanceRootVolumeIsEbs",
      "action": "aws:assertAwsResourceProperty",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "PropertySelector": "$.Reservations[0].Instances[0].RootDeviceType",
        "DesiredValues": [
          "ebs"
        ]
      },
      "isCritical": "true",
      "nextStep": "assertInstanceRootVolumeIsNotEncrypted"
    },
    {
      "name": "assertInstanceRootVolumeIsNotEncrypted",
      "action": "aws:assertAwsResourceProperty",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "Filters": [
          {
            "Name": "attachment.instance-id",
            "Values": [
              "{{ InstanceId }}"
            ]
          },
          {
            "Name": "attachment.device",
            "Values": [
              "{{ describeInstance.RootDeviceName }}"
            ]
          }
        ],
        "PropertySelector": "$.Volumes[0].Encrypted",
        "DesiredValues": [
          "False"
        ]
      },
      "isCritical": "true",
      "nextStep": "branchOnSubnetId"
    },
    {
      "name": "branchOnSubnetId",
      "action": "aws:branch",
      "onFailure": "Abort",
      "inputs": {
        "Choices": [
          {
            "NextStep": "stageEC2RescueAutomationWithInstanceSubnet",
            "Variable": "{{ SubnetId }}",
            "StringEquals": "SelectedInstanceSubnet"
          },
          {
            "NextStep": "stageEC2RescueAutomationWithNewVPC",
            "Variable": "{{ SubnetId }}",
            "StringEquals": "CreateNewVPC"
          }
        ],
        "Default": "assertCustomSubnetIsInSameAZAsInstance"
      },
      "isCritical": "true"
    },
    {
      "name": "stageEC2RescueAutomationWithInstanceSubnet",
      "action": "aws:createStack",
      "onFailure": "step:describeCloudFormationErrorFromStackEvents",
      "inputs": {
        "StackName": "AWSSupport-EC2Rescue-{{ UniqueId }}",
        "TemplateURL": "https://awssupport-ssm.{{ global:REGION }}.s3.amazonaws.com/AWSSupport-StartEC2RescueWorkflow/CloudFormationTemplates/AWSSupport-EC2Rescue_v0a3fa66ae3c6a74ba4bf34341e6de6a0b3358636.template",
        "Capabilities": [
          "CAPABILITY_NAMED_IAM"
        ],
        "ClientRequestToken": "AWSSupport-EC2Rescue-{{ UniqueId }}",
        "Parameters": [
          {
            "ParameterKey": "AZ",
            "ParameterValue": "{{ describeInstance.AvailabilityZone }}"
          },
          {
            "ParameterKey": "SubnetId",
            "ParameterValue": "{{ describeInstance.SubnetId }}"
          },
          {
            "ParameterKey": "Platform",
            "ParameterValue": "{{ describeInstance.Platform }}"
          },
          {
            "ParameterKey": "ExecutionId",
            "ParameterValue": "{{ UniqueId }}"
          }
        ],
        "Tags": [
          {
            "Key": "Name",
            "Value": "AWSSupport-EC2Rescue: {{ InstanceId }}"
          },
          {
            "Key": "AWSSupport-EC2Rescue-AutomationExecution",
            "Value": "{{ UniqueId }}"
          }
        ]
      },
      "isCritical": "true",
      "nextStep": "ensureNoConcurrentExecutionsForTheInstance"
    },
    {
      "name": "stageEC2RescueAutomationWithNewVPC",
      "action": "aws:createStack",
      "onFailure": "step:describeCloudFormationErrorFromStackEvents",
      "inputs": {
        "StackName": "AWSSupport-EC2Rescue-{{ UniqueId }}",
        "TemplateURL": "https://awssupport-ssm.{{ global:REGION }}.s3.amazonaws.com/AWSSupport-StartEC2RescueWorkflow/CloudFormationTemplates/AWSSupport-EC2Rescue_v0a3fa66ae3c6a74ba4bf34341e6de6a0b3358636.template",
        "Capabilities": [
          "CAPABILITY_NAMED_IAM"
        ],
        "ClientRequestToken": "AWSSupport-EC2Rescue-{{ UniqueId }}",
        "Parameters": [
          {
            "ParameterKey": "AZ",
            "ParameterValue": "{{ describeInstance.AvailabilityZone }}"
          },
          {
            "ParameterKey": "SubnetId",
            "ParameterValue": ""
          },
          {
            "ParameterKey": "Platform",
            "ParameterValue": "{{ describeInstance.Platform }}"
          },
          {
            "ParameterKey": "ExecutionId",
            "ParameterValue": "{{ UniqueId }}"
          }
        ],
        "Tags": [
          {
            "Key": "Name",
            "Value": "AWSSupport-EC2Rescue: {{ InstanceId }}"
          },
          {
            "Key": "AWSSupport-EC2Rescue-AutomationExecution",
            "Value": "{{ UniqueId }}"
          }
        ]
      },
      "isCritical": "true",
      "nextStep": "ensureNoConcurrentExecutionsForTheInstance"
    },
    {
      "name": "assertCustomSubnetIsInSameAZAsInstance",
      "action": "aws:assertAwsResourceProperty",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeSubnets",
        "SubnetIds": [
          "{{ SubnetId }}"
        ],
        "PropertySelector": "$.Subnets[0].AvailabilityZone",
        "DesiredValues": [
          "{{ describeInstance.AvailabilityZone }}"
        ]
      },
      "isCritical": "true",
      "nextStep": "stageEC2RescueAutomationWithCustomSubnet"
    },
    {
      "name": "stageEC2RescueAutomationWithCustomSubnet",
      "action": "aws:createStack",
      "onFailure": "step:describeCloudFormationErrorFromStackEvents",
      "inputs": {
        "StackName": "AWSSupport-EC2Rescue-{{ UniqueId }}",
        "TemplateURL": "https://awssupport-ssm.{{ global:REGION }}.s3.amazonaws.com/AWSSupport-StartEC2RescueWorkflow/CloudFormationTemplates/AWSSupport-EC2Rescue_v0a3fa66ae3c6a74ba4bf34341e6de6a0b3358636.template",
        "Capabilities": [
          "CAPABILITY_NAMED_IAM"
        ],
        "ClientRequestToken": "AWSSupport-EC2Rescue-{{ UniqueId }}",
        "Parameters": [
          {
            "ParameterKey": "AZ",
            "ParameterValue": "{{ describeInstance.AvailabilityZone }}"
          },
          {
            "ParameterKey": "SubnetId",
            "ParameterValue": "{{ SubnetId }}"
          },
          {
            "ParameterKey": "Platform",
            "ParameterValue": "{{ describeInstance.Platform }}"
          },
          {
            "ParameterKey": "ExecutionId",
            "ParameterValue": "{{ UniqueId }}"
          }
        ],
        "Tags": [
          {
            "Key": "Name",
            "Value": "AWSSupport-EC2Rescue: {{ InstanceId }}"
          },
          {
            "Key": "AWSSupport-EC2Rescue-AutomationExecution",
            "Value": "{{ UniqueId }}"
          }
        ]
      },
      "isCritical": "true",
      "nextStep": "ensureNoConcurrentExecutionsForTheInstance"
    },
    {
      "name": "ensureNoConcurrentExecutionsForTheInstance",
      "action": "aws:invokeLambdaFunction",
      "onFailure": "step:unstageEC2RescueAutomation",
      "inputs": {
        "FunctionName": "AWSSupport-EC2Rescue-Check-{{ UniqueId }}",
        "Payload": "{\"ResourceProperties\": {\"Region\": \"{{ global:REGION }}\", \"InstanceId\": \"{{ InstanceId }}\", \"ExecutionId\": \"{{ automation:EXECUTION_ID }}\", \"UniqueId\": \"{{ UniqueId }}\" }}"
      },
      "isCritical": "true",
      "nextStep": "createEC2RescueInstance"
    },
    {
      "name": "createEC2RescueInstance",
      "action": "aws:executeAwsApi",
      "onFailure": "step:describeCloudFormationErrorFromStackEvents",
      "inputs": {
        "Service": "cloudformation",
        "Api": "UpdateStack",
        "StackName": "AWSSupport-EC2Rescue-{{ UniqueId }}",
        "UsePreviousTemplate": true,
        "ClientRequestToken": "AWSSupport-EC2Rescue-Update-{{ UniqueId }}",
        "Parameters": [
          {
            "ParameterKey": "CreateHelperInstance",
            "ParameterValue": "True"
          },
          {
            "ParameterKey": "AZ",
            "UsePreviousValue": true
          },
          {
            "ParameterKey": "SubnetId",
            "UsePreviousValue": true
          },
          {
            "ParameterKey": "Platform",
            "UsePreviousValue": true
          },
          {
            "ParameterKey": "ExecutionId",
            "UsePreviousValue": true
          }
        ],
        "Capabilities": [
          "CAPABILITY_NAMED_IAM"
        ],
        "Tags": [
          {
            "Key": "Name",
            "Value": "AWSSupport-EC2Rescue: {{ InstanceId }}"
          },
          {
            "Key": "AWSSupport-EC2Rescue-AutomationExecution",
            "Value": "{{ UniqueId }}"
          }
        ]
      },
      "isCritical": "true",
      "nextStep": "waitForEC2RescueInstanceCreation"
    },
    {
      "name": "waitForEC2RescueInstanceCreation",
      "action": "aws:waitForAwsResourceProperty",
      "onFailure": "step:describeCloudFormationErrorFromStackEvents",
      "timeoutSeconds": "600",
      "inputs": {
        "Service": "cloudformation",
        "Api": "DescribeStacks",
        "StackName": "AWSSupport-EC2Rescue-{{ UniqueId }}",
        "PropertySelector": "$.Stacks[0].StackStatus",
        "DesiredValues": [
          "UPDATE_COMPLETE"
        ]
      },
      "isCritical": "true",
      "nextStep": "describeEC2RescueInstance"
    },
    {
      "name": "describeEC2RescueInstance",
      "action": "aws:executeAwsApi",
      "onFailure": "step:unstageEC2RescueAutomation",
      "inputs": {
        "Service": "cloudformation",
        "Api": "DescribeStacks",
        "StackName": "AWSSupport-EC2Rescue-{{ UniqueId }}"
      },
      "outputs": [
        {
          "Name": "EC2RescueInstanceId",
          "Selector": "$.Stacks[0].Outputs[0].OutputValue",
          "Type": "String"
        }
      ],
      "isCritical": "true",
      "nextStep": "waitForEC2RescueInstanceToBeManaged"
    },
    {
      "name": "waitForEC2RescueInstanceToBeManaged",
      "action": "aws:waitForAwsResourceProperty",
      "onFailure": "step:rebootEC2RescueInstance",
      "timeoutSeconds": "600",
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "InstanceInformationFilterList": [
          {
            "key": "InstanceIds",
            "valueSet": [
              "{{ describeEC2RescueInstance.EC2RescueInstanceId }}"
            ]
          }
        ],
        "PropertySelector": "$.InstanceInformationList[0].PingStatus",
        "DesiredValues": [
          "Online"
        ]
      },
      "isCritical": "false",
      "nextStep": "stopInstance"
    },
    {
      "name": "rebootEC2RescueInstance",
      "action": "aws:executeAwsApi",
      "onFailure": "step:unstageEC2RescueAutomation",
      "inputs": {
        "Service": "ec2",
        "Api": "RebootInstances",
        "InstanceIds": [
          "{{ describeEC2RescueInstance.EC2RescueInstanceId }}"
        ]
      },
      "isCritical": "true",
      "nextStep": "waitAgainForEC2RescueInstanceToBeManaged"
    },
    {
      "name": "waitAgainForEC2RescueInstanceToBeManaged",
      "action": "aws:waitForAwsResourceProperty",
      "onFailure": "step:unstageEC2RescueAutomation",
      "timeoutSeconds": "600",
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "InstanceInformationFilterList": [
          {
            "key": "InstanceIds",
            "valueSet": [
              "{{ describeEC2RescueInstance.EC2RescueInstanceId }}"
            ]
          }
        ],
        "PropertySelector": "$.InstanceInformationList[0].PingStatus",
        "DesiredValues": [
          "Online"
        ]
      },
      "isCritical": "true",
      "nextStep": "stopInstance"
    },
    {
      "name": "stopInstance",
      "action": "aws:changeInstanceState",
      "onFailure": "Continue",
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped"
      },
      "isCritical": "false",
      "nextStep": "forceStopInstance"
    },
    {
      "name": "forceStopInstance",
      "action": "aws:changeInstanceState",
      "onFailure": "step:unstageEC2RescueAutomation",
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped",
        "Force": true
      },
      "isCritical": "true",
      "nextStep": "branchOnPreEC2RescueBackup"
    },
    {
      "name": "branchOnPreEC2RescueBackup",
      "action": "aws:branch",
      "onFailure": "Continue",
      "inputs": {
        "Choices": [
          {
            "NextStep": "preScriptBackup",
            "Variable": "{{ CreatePreEC2RescueBackup }}",
            "StringEquals": "True"
          }
        ],
        "Default": "installEC2RescueOnEC2RescueInstance"
      },
      "isCritical": "true"
    },
    {
      "name": "preScriptBackup",
      "action": "aws:executeAwsApi",
      "onFailure": "step:unstageEC2RescueAutomation",
      "inputs": {
        "Service": "ec2",
        "Api": "CreateImage",
        "InstanceId": "{{ InstanceId }}",
        "Description": "Pre-Script Backup AMI Generated by Automation on {{ global:DATE_TIME }} from {{ InstanceId }}.",
        "NoReboot": false,
        "Name": "{{ AMIPrefix }}-Pre-Script-Backup_{{ InstanceId }}_{{ global:DATE_TIME }}"
      },
      "outputs": [
        {
          "Name": "ImageId",
          "Selector": "$.ImageId",
          "Type": "String"
        }
      ],
      "isCritical": "true",
      "nextStep": "tagPreScriptBackup"
    },
    {
      "name": "tagPreScriptBackup",
      "action": "aws:createTags",
      "onFailure": "Continue",
      "inputs": {
        "ResourceType": "EC2",
        "ResourceIds": [
          "{{ preScriptBackup.ImageId }}"
        ],
        "Tags": [
          {
            "Key": "Name",
            "Value": "AWSSupport-EC2Rescue: {{ InstanceId }}"
          },
          {
            "Key": "AWSSupport-EC2Rescue-AutomationExecution",
            "Value": "{{ UniqueId }}"
          }
        ]
      },
      "isCritical": "false",
      "nextStep": "installEC2RescueOnEC2RescueInstance"
    },
    {
      "name": "installEC2RescueOnEC2RescueInstance",
      "action": "aws:runCommand",
      "onFailure": "step:restoreInstanceRootVolumeDeleteOnTerminationState",
      "inputs": {
        "DocumentName": "AWS-ConfigureAWSPackage",
        "InstanceIds": [
          "{{ describeEC2RescueInstance.EC2RescueInstanceId }}"
        ],
        "Parameters": {
          "name": "AWSSupport-EC2Rescue",
          "action": "Install",
          "version": "latest"
        }
      },
      "isCritical": "true",
      "nextStep": "detachInstanceRootVolume"
    },
    {
      "name": "detachInstanceRootVolume",
      "action": "aws:executeAwsApi",
      "onFailure": "Continue",
      "inputs": {
        "Service": "ec2",
        "Api": "DetachVolume",
        "VolumeId": "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
      },
      "isCritical": "true",
      "nextStep": "waitForInstanceRootVolumeToBeDetached"
    },
    {
      "name": "waitForInstanceRootVolumeToBeDetached",
      "action": "aws:waitForAwsResourceProperty",
      "onFailure": "Continue",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "VolumeIds": [
          "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
        ],
        "PropertySelector": "$.Volumes[0].State",
        "DesiredValues": [
          "available"
        ]
      },
      "isCritical": "true",
      "nextStep": "branchOnPlatform"
    },
    {
      "name": "branchOnPlatform",
      "action": "aws:branch",
      "onFailure": "Continue",
      "inputs": {
        "Choices": [
          {
            "NextStep": "attachInstanceRootVolumeToWindowsEC2RescueInstance",
            "Variable": "{{ describeInstance.Platform }}",
            "StringEquals": "windows"
          }
        ],
        "Default": "attachInstanceRootVolumeToLinuxEC2RescueInstance"
      },
      "isCritical": "true"
    },
    {
      "name": "attachInstanceRootVolumeToWindowsEC2RescueInstance",
      "action": "aws:executeAwsApi",
      "onFailure": "Continue",
      "inputs": {
        "Service": "ec2",
        "Api": "AttachVolume",
        "Device": "xvdf",
        "InstanceId": "{{ describeEC2RescueInstance.EC2RescueInstanceId }}",
        "VolumeId": "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
      },
      "isCritical": "true",
      "nextStep": "waitForInstanceRootVolumeToBeAttachedToWindowsEC2RescueInstance"
    },
    {
      "name": "waitForInstanceRootVolumeToBeAttachedToWindowsEC2RescueInstance",
      "action": "aws:waitForAwsResourceProperty",
      "onFailure": "Continue",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "VolumeIds": [
          "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
        ],
        "PropertySelector": "$.Volumes[0].State",
        "DesiredValues": [
          "in-use"
        ]
      },
      "isCritical": "true",
      "nextStep": "waitBeforeRunningScriptForWindows"
    },
    {
      "name": "waitBeforeRunningScriptForWindows",
      "action": "aws:sleep",
      "onFailure": "Continue",
      "inputs": {
        "Duration": "PT30S"
      },
      "isCritical": "false",
      "nextStep": "runScriptForWindows"
    },
    {
      "name": "runScriptForWindows",
      "action": "aws:runCommand",
      "onFailure": "Continue",
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ describeEC2RescueInstance.EC2RescueInstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "Import-Module EC2Rescue",
            "",
            "try {",
            "    #region Set volume online and set global variables for the system",
            "    $env:EC2RESCUE_OFFLINE_EBS_DEVICE = \"xvdf\"",
            "    $env:EC2RESCUE_EC2RW_DIR = \"${env:PROGRAMFILES}\\Amazon\\EC2Rescue\"",
            "    $originalDrives = Get-PSDrive -PSProvider FileSystem",
            "    & \"${env:EC2RESCUE_EC2RW_DIR}\\EC2RescueCmd.exe\" /accepteula /offline:${env:EC2RESCUE_OFFLINE_EBS_DEVICE} /rescue:all /check-only /no-offline /no-fix-signature | Out-Null",
            "    $newDrives = Get-PSDrive -PSProvider FileSystem",
            "    $driveLetters = (Compare-Object $newDrives $originalDrives).InputObject.Name",
            "    if ($driveLetters) {",
            "        Write-Host \"Device $env:EC2RESCUE_OFFLINE_EBS_DEVICE mapped to $driveLetters\";",
            "        foreach ($driveLetter in $driveLetters) {",
            "            $OfflineWindowsInstall = Get-WindowsInstallData -OfflineWinDrive $driveLetter -IgnoreFailure",
            "            if ($OfflineWindowsInstall) {",
            "                $env:EC2RESCUE_ACCOUNT_ID = \"{{ global:ACCOUNT_ID }}\"",
            "                $env:EC2RESCUE_DATE = \"{{ global:DATE }}\"",
            "                $env:EC2RESCUE_DATE_TIME = \"{{ global:DATE_TIME }}\"",
            "                $env:EC2RESCUE_EXECUTION_ID = \"{{ automation:EXECUTION_ID }}\"",
            "                $env:EC2RESCUE_OFFLINE_CURRENT_CONTROL_SET = $OfflineWindowsInstall.CurrentControlSet",
            "                $env:EC2RESCUE_OFFLINE_DRIVE = $OfflineWindowsInstall.OfflineWindowsDrive",
            "                #$env:EC2RESCUE_OFFLINE_EBS_DEVICE set earlier in the script",
            "                $env:EC2RESCUE_OFFLINE_KERNEL_VER = $OfflineWindowsInstall.KernelVer",
            "                $env:EC2RESCUE_OFFLINE_OS_ARCHITECTURE = $OfflineWindowsInstall.OSArchitecture",
            "                $env:EC2RESCUE_OFFLINE_OS_TYPE = $OfflineWindowsInstall.OSType",
            "                $env:EC2RESCUE_OFFLINE_OS_CAPTION = $OfflineWindowsInstall.OSCaption",
            "                $env:EC2RESCUE_OFFLINE_PROGRAM_FILES_DIR = $OfflineWindowsInstall.ProgramFilesDir",
            "                $env:EC2RESCUE_OFFLINE_PROGRAM_FILES_X86_DIR = $OfflineWindowsInstall.ProgramFilesDirx86",
            "                $env:EC2RESCUE_OFFLINE_REGISTRY_DIR = $OfflineWindowsInstall.RegistryDir",
            "                $env:EC2RESCUE_OFFLINE_SYSTEM_ROOT = $OfflineWindowsInstall.SystemRoot",
            "                #$env:EC2RESCUE_PATH already set during package installation",
            "                $env:EC2RESCUE_REGION = \"{{ global:REGION }}\"",
            "                $env:EC2RESCUE_S3_BUCKET = \"{{ S3BucketName }}\"",
            "                $env:EC2RESCUE_S3_PREFIX = \"{{ S3Prefix }}\"",
            "                $env:EC2RESCUE_SOURCE_INSTANCE = \"{{ InstanceId }}\"",
            "                Write-Host \"EC2Rescue environment variables set\";",
            "                $script:EC2RESCUE_OFFLINE_WINDOWS_INSTALL = $OfflineWindowsInstall",
            "                Write-Host \"EC2Rescue script variables set\";",
            "            }                    ",
            "        }",
            "    }",
            "    #endregion",
            "    ",
            "    #region Execute user-provided script",
            "    $scriptblock = [scriptblock]::Create([System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String('{{ OfflineScript }}')))",
            "    & $scriptblock",
            "    #endregion",
            "",
            "    #region Fix disk signature and set volume offline",
            "    & \"${env:EC2RESCUE_EC2RW_DIR}\\EC2RescueCmd.exe\" /accepteula /offline:${env:EC2RESCUE_OFFLINE_EBS_DEVICE} /rescue:all /check-only | Out-Null",
            "    Write-Host \"Volume successfully set offline\"",
            "    #endregion",
            "}",
            "catch {",
            "    Write-Host $_.Exception.Message",
            "    #Disk signature fix",
            "    & \"${env:EC2RESCUE_EC2RW_DIR}\\EC2RescueCmd.exe\" /accepteula /offline:${env:EC2RESCUE_OFFLINE_EBS_DEVICE} /rescue:all /check-only | Out-Null",
            "    exit 1",
            "}"
          ]
        }
      },
      "isCritical": "true",
      "nextStep": "stopEC2RescueInstance"
    },
    {
      "name": "attachInstanceRootVolumeToLinuxEC2RescueInstance",
      "action": "aws:executeAwsApi",
      "onFailure": "Continue",
      "inputs": {
        "Service": "ec2",
        "Api": "AttachVolume",
        "Device": "/dev/sdf",
        "InstanceId": "{{ describeEC2RescueInstance.EC2RescueInstanceId }}",
        "VolumeId": "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
      },
      "isCritical": "true",
      "nextStep": "waitForInstanceRootVolumeToBeAttachedToLinuxEC2RescueInstance"
    },
    {
      "name": "waitForInstanceRootVolumeToBeAttachedToLinuxEC2RescueInstance",
      "action": "aws:waitForAwsResourceProperty",
      "onFailure": "Continue",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "VolumeIds": [
          "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
        ],
        "PropertySelector": "$.Volumes[0].State",
        "DesiredValues": [
          "in-use"
        ]
      },
      "isCritical": "true",
      "nextStep": "waitBeforeRunningScriptForLinux"
    },
    {
      "name": "waitBeforeRunningScriptForLinux",
      "action": "aws:sleep",
      "onFailure": "Continue",
      "inputs": {
        "Duration": "PT30S"
      },
      "isCritical": "false",
      "nextStep": "runScriptForLinux"
    },
    {
      "name": "runScriptForLinux",
      "action": "aws:runCommand",
      "onFailure": "Continue",
      "inputs": {
        "DocumentName": "AWS-RunShellScript",
        "InstanceIds": [
          "{{ describeEC2RescueInstance.EC2RescueInstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "#!/bin/sh",
            "# {{ InstanceId }} -> instance to which the rescue volume belongs",
            "# {{ S3BucketName }} -> S3 bucket where the logs should be uploaded",
            "error_trap()",
            "{",
            "    if test -n \"$1\" ; then",
            "        printf \"%s\\\\n\" \"$1\"",
            "    fi",
            "",
            "    printf \"%.s=\" $(seq 1 80)",
            "    printf \"\\\\nThe EC2Rescue execution did not complete successfully.\\\\n\"",
            "",
            "    cleanup",
            "",
            "    exit 1",
            "}",
            "",
            "cleanup()",
            "{",
            "    # Recreate the symlink if resolv.conf was one",
            "    if test \"${RESOLV_CONF_IS_SYMLINK}\" == \"True\"; then",
            "        cd \"${CHROOT}\"",
            "        if test -e etc/resolv.conf; then",
            "            rm -v etc/resolv.conf",
            "        fi",
            "        ln -s \"${SYMLINK_TARGET}\" etc/resolv.conf",
            "        cd - 1>/dev/null",
            "    # Restore original resolv.conf if it was backed up",
            "    elif test -e \"${CHROOT}\"/etc/resolv.conf.back ; then",
            "        mv -v \"${CHROOT}\"/etc/resolv.conf.back \"${CHROOT}/etc/resolv.conf\"",
            "    fi",
            "",
            "    if mount | grep -qc /mnt/mount ; then",
            "        umount -vR \"${CHROOT}\" 2>&1",
            "    fi",
            "}",
            "export CHROOT=/mnt/mount",
            "unalias -a",
            "",
            "# Check that a compatible Python interpreter is available in the host environemnt",
            "if command -v python3 > /dev/null; then",
            "    PYTHON=python3",
            "elif command -v python2.7 > /dev/null; then",
            "    PYTHON=python2.7",
            "else",
            "    error_trap \"Failed to find compatible Python environment!\"",
            "fi",
            "",
            "# Find the root file system on the rescue volume",
            "printf \"Locating rescue device\\\\n\"",
            "RESCUE_DEVICE=\"$(${PYTHON} -c \"",
            "from __future__ import print_function",
            "import ctypes",
            "import ctypes.util",
            "import os",
            "import re",
            "import shlex",
            "import subprocess",
            "import sys",
            "",
            "EXPECTED_ROOT_FS_DIRS = {'bin', 'boot', 'dev', 'etc', 'home', 'proc', 'root', 'sbin', 'sys', 'tmp', 'usr', 'var'}",
            "MOUNT_POINT = os.environ['CHROOT']",
            "LIBC = ctypes.CDLL(ctypes.util.find_library('c'), use_errno=True)",
            "",
            "",
            "def contains_root_fs(device_name):",
            "    if not os.path.isdir(MOUNT_POINT):",
            "        os.makedirs(MOUNT_POINT)",
            "    # TODO find a more native way to obtain the filesystem type",
            "    try:",
            "        fs_type = subprocess.check_output(shlex.split('blkid {} -s TYPE -o value'.format(device_name)),",
            "                                          universal_newlines=True).strip()",
            "    except Exception:",
            "        return False",
            "    try:",
            "        # Python does not have a builtin for mount so use libc to do it",
            "        # Ref: https://www.gnu.org/software/libc/manual/html_node/Mount_002dUnmount_002dRemount.html",
            "        # ctypes does not automatically convert unicode/byte strings so it is necessary to encode them in Python 3",
            "        ret = LIBC.mount(device_name.encode('ascii'), MOUNT_POINT.encode('ascii'), fs_type.encode('ascii'), 0, None)",
            "        if ret:",
            "            # the_errno = ctypes.get_errno()",
            "            # print('Failed to mount {}. {}'.format(device_name, os.strerror(the_errno)))",
            "            return False",
            "        if EXPECTED_ROOT_FS_DIRS & set(os.listdir(MOUNT_POINT)) == EXPECTED_ROOT_FS_DIRS:",
            "            return True",
            "        else:",
            "            return False",
            "    finally:",
            "        LIBC.umount(MOUNT_POINT.encode('ascii'))",
            "",
            "",
            "def run():",
            "    # This detection method relies on udev's standard storage naming rules",
            "    # https://cgit.freedesktop.org/systemd/systemd/tree/rules/60-persistent-storage.rules",
            "    partitions = list()",
            "    device_mapping = dict()",
            "    root_fs_dev = ''",
            "    possible_rescue_vol_root_fs_dev = list()",
            "    part_regex = re.compile(r'^.*part\\d*$')",
            "",
            "    os.chdir('/dev/disk/by-path/')",
            "    for device_path in os.listdir('/dev/disk/by-path'):",
            "        device_abs_path = os.path.join(os.path.abspath(os.readlink(device_path)))",
            "        if re.match(part_regex, device_path):",
            "            partitions.append(device_abs_path)",
            "        else:",
            "            device_mapping[device_abs_path] = list()",
            "    for device_name in device_mapping.keys():",
            "        for partition_name in partitions:",
            "            if device_name in partition_name:",
            "                device_mapping[device_name].append(partition_name)",
            "",
            "    with open('/proc/mounts') as proc_mounts:",
            "        for mount in proc_mounts:",
            "            mount = mount.split()",
            "            if mount[1] == '/':",
            "                root_fs_dev = mount[0]",
            "                break",
            "    if not root_fs_dev:",
            "        return 'Error: failed to find device name of root volume.'",
            "",
            "    for block_dev_name in device_mapping.keys():",
            "        # If the root device is a disk",
            "        if block_dev_name == root_fs_dev:",
            "            break",
            "        # If the root device is a partition",
            "        else:",
            "            if root_fs_dev in device_mapping[block_dev_name]:",
            "                root_fs_dev = block_dev_name",
            "                break",
            "    del device_mapping[root_fs_dev]",
            "    if not device_mapping:",
            "        return 'Error: no rescue volume attached.'",
            "",
            "    for possible_rescue_vol_dev in device_mapping.keys():",
            "        # Volume does not use partitions",
            "        if len(device_mapping[possible_rescue_vol_dev]) == 0:",
            "            if contains_root_fs(possible_rescue_vol_dev):",
            "                possible_rescue_vol_root_fs_dev.append(possible_rescue_vol_dev)",
            "        # Volume contains one or more partitions",
            "        else:",
            "            for partition_name in device_mapping[possible_rescue_vol_dev]:",
            "                if contains_root_fs(partition_name):",
            "                    possible_rescue_vol_root_fs_dev.append(partition_name)",
            "",
            "    if len(possible_rescue_vol_root_fs_dev) == 1:",
            "        print(possible_rescue_vol_root_fs_dev[0])",
            "    elif len(possible_rescue_vol_root_fs_dev) > 1:",
            "        return 'Error: found more than one possible rescue volume with a root filesystem: {}'.format(",
            "            ', '.join(possible_rescue_vol_root_fs_dev))",
            "    else:",
            "        return 'Error: failed to find a rescue volume with a root filesystem.'",
            "",
            "",
            "if __name__ == '__main__':",
            "    sys.exit(run())",
            "\")\" || error_trap",
            "",
            "# Unlabel the rescue instance's root volume to prevent false positive detection of duplicate labels",
            "e2label /dev/xvda1 \"\" || error_trap \"Failed to unlabel the rescue instance's root volume\"",
            "sed -i \"s|LABEL=/|UUID=$(blkid /dev/xvda1 -s UUID -o value)|\" /etc/fstab || error_trap \"Failed to update /etc/fstab on rescue instance\"",
            "",
            "# Prepare for chroot",
            "printf \"Mounting rescue volume %s\\\\n\" \"${RESCUE_DEVICE}\" || error_trap",
            "mount \"${RESCUE_DEVICE}\" \"${CHROOT}\" || error_trap",
            "mount -R /sys \"${CHROOT}\"/sys || error_trap",
            "mount --make-rslave \"${CHROOT}\"/sys || error_trap",
            "mount -R /dev \"${CHROOT}\"/dev || error_trap",
            "mount --make-rslave \"${CHROOT}\"/dev || error_trap",
            "mount -t proc /proc \"${CHROOT}\"/proc || error_trap",
            "",
            "RESOLV_CONF_IS_SYMLINK=False",
            "SYMLINK_TARGET=\"\"",
            "# /etc/resolv.conf is a symlink in Ubuntu so dereference the symlink if needed",
            "if test -h \"${CHROOT}/etc/resolv.conf\"; then",
            "    RESOLV_CONF_IS_SYMLINK=True",
            "    SYMLINK_TARGET=$(readlink \"${CHROOT}/etc/resolv.conf\")",
            "    unlink \"${CHROOT}/etc/resolv.conf\"",
            "    printf \"unlink %s\\\\n\" \"${CHROOT}/etc/resolv.conf\"",
            "elif test -e \"${CHROOT}/etc/resolv.conf\" ; then",
            "    cp -v \"${CHROOT}/etc/resolv.conf\" \"${CHROOT}\"/etc/resolv.conf.back || error_trap",
            "fi",
            "cp -v /etc/resolv.conf \"${CHROOT}/etc/resolv.conf\" || error_trap",
            "",
            "# Copy ec2rl from the rescue host to the rescue slave/volume",
            "# This may \"upgrade\" the version on the rescue volume if it was already installed",
            "EC2RL_DIR=\"$(dirname \"$(readlink /usr/bin/ec2rl)\")\"",
            "mkdir -vp \"$(dirname \"${CHROOT}\"\"${EC2RL_DIR}\")\" || error_trap",
            "cp -r \"${EC2RL_DIR}\" \"${CHROOT}\"\"$(dirname ${EC2RL_DIR})\" || error_trap \"Failed to copy ec2rl to rescue volume\"",
            "",
            "mkdir -vp \"${CHROOT}\"/usr/bin || error_trap \"Failed to create ${CHROOT}/usr/bin\"",
            "",
            "rm -v \"${CHROOT}\"/usr/bin/ec2rl",
            "ln -vs \"${EC2RL_DIR}\"/ec2rl \"${CHROOT}\"/usr/bin/ec2rl || error_trap \"Failed to create ec2rl symlink\"",
            "",
            "export EC2RESCUE_ACCOUNT_ID=\"{{ global:ACCOUNT_ID }}\"",
            "export EC2RESCUE_DATE=\"{{ global:DATE }}\"",
            "export EC2RESCUE_DATE_TIME=\"{{ global:DATE_TIME }}\"",
            "export EC2RESCUE_REGION=\"{{ global:REGION }}\"",
            "export EC2RESCUE_EXECUTION_ID=\"{{ automation:EXECUTION_ID }}\"",
            "export EC2RESCUE_SOURCE_INSTANCE=\"{{ InstanceId }}\"",
            "export EC2RESCUE_S3_BUCKET=\"{{ S3BucketName }}\"",
            "export EC2RESCUE_S3_PREFIX=\"{{ S3Prefix }}\"",
            "export EC2RESCUE_OFFLINE_EBS_DEVICE=\"/dev/sdf\"",
            "export EC2RESCUE_OFFLINE_DEVICE=$RESCUE_DEVICE",
            "export EC2RESCUE_OFFLINE_SYSTEM_ROOT=$CHROOT",
            "export EC2RESCUE_PYTHON=$PYTHON",
            "export EC2RESCUE_EC2RL_DIR=$EC2RL_DIR",
            "",
            "base64 -d <<< {{ OfflineScript }} | /bin/bash ",
            "",
            "cleanup"
          ]
        }
      },
      "isCritical": "true",
      "nextStep": "stopEC2RescueInstance"
    },
    {
      "name": "stopEC2RescueInstance",
      "action": "aws:changeInstanceState",
      "onFailure": "Continue",
      "inputs": {
        "InstanceIds": [
          "{{ describeEC2RescueInstance.EC2RescueInstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped"
      },
      "isCritical": "false",
      "nextStep": "forceStopEC2RescueInstance"
    },
    {
      "name": "forceStopEC2RescueInstance",
      "action": "aws:changeInstanceState",
      "onFailure": "Continue",
      "inputs": {
        "InstanceIds": [
          "{{ describeEC2RescueInstance.EC2RescueInstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped",
        "Force": true
      },
      "isCritical": "true",
      "nextStep": "detachInstanceRootVolumeFromEC2RescueInstance"
    },
    {
      "name": "detachInstanceRootVolumeFromEC2RescueInstance",
      "onFailure": "Continue",
      "action": "aws:executeAwsApi",
      "inputs": {
        "Service": "ec2",
        "Api": "DetachVolume",
        "VolumeId": "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
      },
      "isCritical": "true",
      "nextStep": "waitForRescuedInstanceRootVolumeToBeDetached"
    },
    {
      "name": "waitForRescuedInstanceRootVolumeToBeDetached",
      "action": "aws:waitForAwsResourceProperty",
      "onFailure": "Continue",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "VolumeIds": [
          "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
        ],
        "PropertySelector": "$.Volumes[0].State",
        "DesiredValues": [
          "available"
        ]
      },
      "isCritical": "true",
      "nextStep": "attachInstanceRootVolumeToInstance"
    },
    {
      "name": "attachInstanceRootVolumeToInstance",
      "onFailure": "Continue",
      "action": "aws:executeAwsApi",
      "inputs": {
        "Service": "ec2",
        "Api": "AttachVolume",
        "Device": "{{ describeInstance.RootDeviceName }}",
        "InstanceId": "{{ InstanceId }}",
        "VolumeId": "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
      },
      "isCritical": "true",
      "nextStep": "waitForRescuedInstanceRootVolumeToBeAttached"
    },
    {
      "name": "waitForRescuedInstanceRootVolumeToBeAttached",
      "action": "aws:waitForAwsResourceProperty",
      "onFailure": "Continue",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "VolumeIds": [
          "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
        ],
        "PropertySelector": "$.Volumes[0].State",
        "DesiredValues": [
          "in-use"
        ]
      },
      "isCritical": "true",
      "nextStep": "branchOnPostEC2RescueBackup"
    },
    {
      "name": "branchOnPostEC2RescueBackup",
      "action": "aws:branch",
      "onFailure": "Continue",
      "inputs": {
        "Choices": [
          {
            "NextStep": "postScriptBackup",
            "Variable": "{{ CreatePostEC2RescueBackup }}",
            "StringEquals": "True"
          }
        ],
        "Default": "restoreInstanceRootVolumeDeleteOnTerminationState"
      },
      "isCritical": "true"
    },
    {
      "name": "postScriptBackup",
      "action": "aws:executeAwsApi",
      "onFailure": "Continue",
      "inputs": {
        "Service": "ec2",
        "Api": "CreateImage",
        "InstanceId": "{{ InstanceId }}",
        "Description": "Post-Script Backup AMI Generated by Automation on {{ global:DATE_TIME }} from {{ InstanceId }}.",
        "NoReboot": false,
        "Name": "{{ AMIPrefix }}-Post-Script-Backup_{{ InstanceId }}_{{ global:DATE_TIME }}"
      },
      "outputs": [
        {
          "Name": "ImageId",
          "Selector": "$.ImageId",
          "Type": "String"
        }
      ],
      "isCritical": "true",
      "nextStep": "tagPostScriptBackup"
    },
    {
      "name": "tagPostScriptBackup",
      "action": "aws:createTags",
      "onFailure": "Continue",
      "inputs": {
        "ResourceType": "EC2",
        "ResourceIds": [
          "{{ postScriptBackup.ImageId }}"
        ],
        "Tags": [
          {
            "Key": "Name",
            "Value": "AWSSupport-EC2Rescue: {{ InstanceId }}"
          },
          {
            "Key": "AWSSupport-EC2Rescue-AutomationExecution",
            "Value": "{{ UniqueId }}"
          }
        ]
      },
      "isCritical": "false",
      "nextStep": "restoreInstanceRootVolumeDeleteOnTerminationState"
    },
    {
      "name": "restoreInstanceRootVolumeDeleteOnTerminationState",
      "onFailure": "Continue",
      "action": "aws:executeAwsApi",
      "inputs": {
        "Service": "ec2",
        "Api": "ModifyInstanceAttribute",
        "InstanceId": "{{ InstanceId }}",
        "BlockDeviceMappings": [
          {
            "DeviceName": "{{ describeInstance.RootDeviceName }}",
            "Ebs": {
              "DeleteOnTermination": "{{ describeInstanceRootVolume.RootDeviceDeleteOnTermination }}",
              "VolumeId": "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
            }
          }
        ]
      },
      "isCritical": "true",
      "nextStep": "restoreInstanceInitialState"
    },
    {
      "name": "restoreInstanceInitialState",
      "action": "aws:changeInstanceState",
      "onFailure": "Continue",
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "DesiredState": "{{ describeInstance.State }}"
      },
      "isCritical": "true",
      "nextStep": "unstageEC2RescueAutomation"
    },
    {
      "name": "describeCloudFormationErrorFromStackEvents",
      "onFailure": "Continue",
      "action": "aws:executeAwsApi",
      "inputs": {
        "Service": "cloudformation",
        "Api": "DescribeStackEvents",
        "StackName": "AWSSupport-EC2Rescue-{{ UniqueId }}"
      },
      "outputs": [
        {
          "Name": "Events",
          "Selector": "$.StackEvents..ResourceStatusReason",
          "Type": "StringList"
        }
      ],
      "isCritical": "false",
      "nextStep": "unstageEC2RescueAutomation"
    },
    {
      "name": "unstageEC2RescueAutomation",
      "action": "aws:deleteStack",
      "maxAttempts": 3,
      "inputs": {
        "StackName": "AWSSupport-EC2Rescue-{{ UniqueId }}"
      },
      "isCritical": "true",
      "isEnd": "true"
    }
  ],
  "outputs": [
    "runScriptForLinux.Output",
    "runScriptForWindows.Output",
    "preScriptBackup.ImageId",
    "postScriptBackup.ImageId"
  ]
}
